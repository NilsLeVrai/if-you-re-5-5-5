commencer par:

ISACS + 21. 

removeZeroes() // forcement std::string
on skip tant que ya des 0 et dans la chaine
si on arrive a la fin 0 sinon substr


constructeurs: long, const char*, std::string

long --> stringstream
const char* --> !s || !*s --> temp(s) --> temp.first_not_of("0123456789" != std::string::npos) --> "0" else temp
std::string --> if (!std::isdigit(s[i])) "0" break; ELSE _digits = s;


faire << et <<=
faire >> et >>=


n << k = n * 2^k
n >> k = n / 2^k (pour bitshift mais good to know)

faire les booleens

== 
!=
< check la longueur des deux, return < longueur et <
> return other < *this (utiliser <)
pour <= et >= return !(*this opposite other);

++ post --> (int)

bigint operator++(int) {
	bigint temp = *this;
	++(*this);
	return temp;
}

++ pre --> +1L

bigint& bigint::operator++() {
	*this = *this = bigint(1L);
	return (*this);
}

+= et -=
*this = *this +/- other

faire le + :)
faire 3 chaines de caracteres 
i et j len - 1
carry = 0

on commence par la fin

while (i >= 0 || j >= 0 || carry ) {
	sum = carry;
	if (i >= 0) {
		sum += s1[i--] - '0';
	}
	if (j >= 0) {
		sum += s1[j--] - '0';
	}

	std::stringstream ss;
	ss << (sum % 10);
	result += ss.str();

	carry /= 10;
}
std::reverse(result.begin(), result.end());
return (bigint(result));





